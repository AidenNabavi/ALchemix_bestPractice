#  Smart Contract Vulnerability Report
**Alchemix V3**:

##  Vulnerability Title 

Adapter Misassignment to Unauthorized Vault

## 🗂 Report Type

Smart Contract


## 🔗 Target

- https://github.com/alchemix-finance/v3-poc/blob/immunefi_audit/src/AlchemistCurator.sol



## Asset

AlchemistCurator.sol




##  Rating


Severity: Low ~ Medium


Impact: **High**
   Because the vulnerability allows unauthorized reassignment of adapters between vaults, it can directly redirect yield or assets to unintended destinations, leading to potential **fund loss** and **protocol accounting inconsistencies**.


Likelihood: Low 


Attack Complexity : Low





##  Description


The `setStrategy()` function in `AlchemistCurator.sol` allows an operator to assign an adapter (strategy) to a vault (MYT) without verifying whether the adapter was previously assigned to another vault.

This results in a silent overwriting of the existing mapping in adapterToMYT, effectively reassigning the adapter to a new vault and potentially 

breaking existing strategy–vault relationships.

Since adapters represent yield strategies that interact with external protocols, overwriting their vault bindings can lead to misrouted yield, 

accounting corruption, or loss of access to strategy funds.


##  Impact


   - The yield generated by strategies may be sent to the wrong vault, causing accounting mismatches.  


   - Overwriting the adapter → vault mapping without checks can lead to  incorrect internal protocol reporting and calculations.  


   - Strategies may connect to the wrong vault, potentially disrupting their execution or causing transactions to revert.



##  Vulnerability Details

The function below is vulnerable:👇🏽

```solidity 


    function _setStrategy(address adapter, address myt, bool remove) internal {
        adapterToMYT[adapter] = myt;
        IVaultV2 vault = _vault(adapter);
        if (remove) {
            vault.removeAdapter(adapter);
        } else {
            vault.addAdapter(adapter);
        }
        emit StrategySet(adapter, myt);
    }

    
```





##  Proof of Concept (PoC)

🐧 **Flow**

In the `AlchemistCurator` contract, there is a function called `setStrategy()` that connects an adapter to a vault.

This `setStrategy()` function internally calls `_setStrategy()`, which actually links the given adapter to the specified vault.

However, `_setStrategy()` does `not check` whether the adapter was previously connected to another vault or not ?

— it simply `overwrites` the existing mapping.



🐧**Step by Step**  :

full POC  download  and run  👇🏽


```solidity 

// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import {AlchemistCurator} from "../src/AlchemistCurator.sol";




/// @notice This interface replaces the original import: 
/// `import {IVaultV2} from "../lib/IVaultV2.sol";`
///
///@notice The reason for creating this local interface is to simplify the setup:
/// we only need a minimal Vault interface that exposes `addAdapter` and `removeAdapter`
/// for testing purposes. 
///
///@notice It has **no effect on the behavior** of the `_setStrategy()` function.
interface _IVaultV2 {
    function addAdapter(address adapter) external;
    function removeAdapter(address adapter) external;
    function submit(bytes calldata data) external;
    function decreaseRelativeCap(bytes memory id, uint256 amount) external;
    function decreaseAbsoluteCap(bytes memory id, uint256 amount) external;
    function increaseRelativeCap(bytes memory id, uint256 amount) external;
    function increaseAbsoluteCap(bytes memory id, uint256 amount) external;
}



/// @notice This mock contract represents a Vault entity.
/// We need a Vault instance to assign adapters to it in the test.
///
/// The functions here are implemented only for  compatibility
/// with the `_IVaultV2` interface — they do not affect the behavior
/// of `_setStrategy()` in any way.
///
/// @notice It simply shows that a Vault entity exists, which allows
/// the Curator contract to interact with it as expected.

contract MockVault is _IVaultV2 {
    address public lastAddedAdapter;
    address public lastRemovedAdapter;

    function addAdapter(address adapter) external override {
        lastAddedAdapter = adapter;
    }
    function removeAdapter(address adapter) external override {
        lastRemovedAdapter = adapter;
    }
    function submit(bytes calldata) external override {}
    function decreaseRelativeCap(bytes memory, uint256) external override {}
    function decreaseAbsoluteCap(bytes memory, uint256) external override {}
    function increaseRelativeCap(bytes memory, uint256) external override {}
    function increaseAbsoluteCap(bytes memory, uint256) external override {}
}



/// @notice This mock contract represents an Adapter entity.
/// It is only used to provide an address that can be linked to Vaults
/// through the `_setStrategy()` function.
///
/// @dev No internal logic is required — only the address matters.  
contract Adaptor {

}


//test start🐧
contract TestAdapterReassignment is Test {
    AlchemistCurator curator;
    Adaptor adapter;

    /// @notice We create two Vaults because we want to verify whether
    /// a single adapter can be assigned to two different Vaults simultaneously.
    MockVault vault1;
    MockVault vault2;

    address admin = address(0xAAA1);
    address operator = address(0xBBB2);

    function setUp() public {
        curator = new AlchemistCurator(admin, operator);
        vault1 = new MockVault();
        vault2 = new MockVault();
        adapter = new Adaptor();
        

        vm.startPrank(operator);  
        curator.setStrategy(address(adapter), address(vault1));
        vm.stopPrank();
        address mappedVault1 = curator.adapterToMYT(address(adapter));
        console.log("mapped vault address that connected to adaptor from befor ----------->",mappedVault1);


    }

    
    function test_AdapterCanBeReassignedToDifferentVault_WithoutAnyCheck() public {
        vm.startPrank(operator);

        // This mapping is defined in the AlchemistCurator contract:
        // mapping(address => address) public adapterToMYT;

        // In this step, we attempt to assign the same adapter to a new vault (vault2)
        curator.setStrategy(address(adapter), address(vault2));

        address mappedVault2 = curator.adapterToMYT(address(adapter));
        console.log("Mapped vault address connected now ------------> ", mappedVault2);

        /// @notice At this point, the adapter has been successfully re-bound from vault1 to vault2.
        /// @notice However, there is **no validation or safety check** to ensure that the adapter
        ///         wasn’t already connected to a previous vault.
        ///
        /// @notice The function should either:
        ///         - enforce a prior call to `removeStrategy()` before call setStrategy() , or
        ///         - add a validation check inside `_setStrategy()` to prevent reassignment
        ///           if the adapter is already mapped to another vault.

        assertEq(mappedVault2, address(vault2), "Adapter mapping was not overwritten as expected!");

        vm.stopPrank();
}


}


    
```





## How to fix it (Recommended)


//follow comment 👇🏽

```solidity 


function _setStrategy(address adapter, address myt, bool remove) internal {

    ///@notice --------> In this contract --->vault , hasAdapter() function  should be implemented as follows:
    IVaultV2 vault = _vault(adapter);

    if (!remove) {
        // For the add operation, check that the adapter is not already connected
        bool hasAdaptor = vault.hasAdapter(adapter);
        require(!hasAdaptor, "Adapter already connected to a vault");
    }

    // Update the mapping
    adapterToMYT[adapter] = myt;

    if (remove) {
        vault.removeAdapter(adapter);
    } else {
        vault.addAdapter(adapter);
    }

    emit StrategySet(adapter, myt);
}



```
* For the `add operation`, we first check that the adapter is not already connected.

* For the `remove operation`, no check is needed because we are detaching the adapter from the vault.

* The message in `require` ensures that if the condition fails, the transaction reverts with a clear reason.






## 🔗 References

- https://github.com/alchemix-finance/v3-poc/blob/immunefi_audit/src/AlchemistCurator.sol






